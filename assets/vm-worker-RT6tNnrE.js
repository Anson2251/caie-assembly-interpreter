var L=Object.defineProperty;var B=(u,i,n)=>i in u?L(u,i,{enumerable:!0,configurable:!0,writable:!0,value:n}):u[i]=n;var o=(u,i,n)=>B(u,typeof i!="symbol"?i+"":i,n);(function(){"use strict";function u(s,e){const t=1<<e-1;return s&t?s-(1<<e):s}function i(s,e){const t=(1<<e)-1;return s&t}function n(s,e){if(e>=32)throw new Error("OverflowToBinary cannot handle values greater than 32 bits currently.");return s&(1<<e)-1}function b(s,e,t){return n(s+e,t)}function I(s,e,t){return n(s-e,t)}function E(s,e){return s>>>e}function V(s,e){return s<<e}function f(s,e,t){const r=s&1<<t-1;return s>>e|r}function y(s,e,t){return s<<e|s>>>t-e}function N(s,e,t){return s>>>e|s<<t-e}const k=["ACC","CIR","IX","MAR","MDR","PC"],A=s=>{if(s<0||s>5)throw new Error("Invalid register ID");return k[s]};class l{constructor(e,t){o(this,"value");o(this,"type");o(this,"bits");this.type=e,this.value=0,this.bits=t}setValue(e){this.value=n(e,this.bits)}getValue(){return this.value}decreaseBy(e){this.setValue(i(n(this.value-e,this.bits),this.bits))}increaseBy(e){this.setValue(i(n(this.value+e,this.bits),this.bits))}getType(){return this.type}}const c={LDM:0,LDD:1,LDI:2,LDX:3,LDR:4,MOV:5,STO:6,LDR_ACC:7},D={IN:16,OUT:17},g={ADD_ADDRESS:32,ADD_IMMEDIATE:33,SUB_ADDRESS:34,SUB_IMMEDIATE:35,INC:36,DEC:37},C={JMP:48,JPE:49,JPN:50,END:51,JMR:52},p={CMP_ADDRESS:64,CMP_IMMEDIATE:65,CMI:66},d={LSL:80,LSR:81,ASR:82,CSL:83,CSR:84},h={AND_IMMEDIATE:96,AND_ADDRESS:97,OR_IMMEDIATE:98,OR_ADDRESS:99,XOR_IMMEDIATE:100,XOR_ADDRESS:101,NOT:102},m={...c,...D,...g,...C,...p,...d,...h};function v(s){return Object.keys(m).find(e=>m[e]===s)||"UNKNOWN"}class w{constructor(e=16){o(this,"registers");o(this,"bits");o(this,"memory",{});o(this,"end",!0);o(this,"jumped",!1);o(this,"inputDevice");o(this,"outputDevice");o(this,"verbose",!1);o(this,"sr");if(e<8)throw new Error("Bits must be greater than 8");this.registers={ACC:new l("ACC",e),IX:new l("IX",e),CIR:new l("CIR",e),MAR:new l("MAR",e),MDR:new l("MDR",e),PC:new l("PC",e)},this.bits=e,this.sr={c:0,n:0,o:0,z:0},this.inputDevice=async()=>{throw new Error("No input device")},this.outputDevice=async t=>{console.log("No output device",t)}}getBits(){return this.bits}addDevice(e,t){e==="input"&&(this.inputDevice=t),e==="output"&&(this.outputDevice=t)}setMemory(e,t){this.registers.MAR.setValue(e),this.registers.MDR.setValue(n(t,this.bits)),this.writeMemory()}writeMemory(){const e=this.registers.MDR.getValue()||0,t=this.registers.MAR.getValue();this.memory[t]=e}fetchMemory(){const e=this.registers.MAR.getValue(),t=this.memory[e]||0;this.registers.MDR.setValue(t)}readMemory(e){return this.registers.MAR.setValue(e),this.fetchMemory(),this.registers.MDR.getValue()}setStatusRegister(e,t){this.sr[e]=t}isCMPSuccessful(){return this.sr.c===0&&this.sr.n===0&&this.sr.z===1}setStatusRegisterWithNumber(e){e===0?(this.setStatusRegister("c",0),this.setStatusRegister("n",0),this.setStatusRegister("z",1)):e<0?(this.setStatusRegister("c",1),this.setStatusRegister("n",1),this.setStatusRegister("z",0)):e>0&&(this.setStatusRegister("c",0),this.setStatusRegister("n",0),this.setStatusRegister("z",0))}async execute(e){let t=0;for(e.forEach(r=>{r.opcode!==255?(this.storeInstructionInMemory(t,r),t+=2):(this.setMemory(t,r.operand),t+=1)}),this.registers.PC.setValue(0),this.end=!1,this.logMemoryAndRegisters();!this.end;){const r=this.fetchDecodeInstruction(this.registers.PC.getValue());this.registers.CIR.setValue(r.opcode),this.registers.MDR.setValue(r.operand),await this.executeInstruction(),this.jumped?this.jumped=!1:this.registers.PC.increaseBy(2),this.logMemoryAndRegisters(),this.verbose&&console.log("")}}logMemoryAndRegisters(){if(!this.verbose)return;console.log("---MEMORY-BEGIN---");const e=Object.keys(this.memory).map(a=>parseInt(a)).sort((a,R)=>a-R),t=e[e.length-1].toString(16).length,r=e[e.length-1];for(let a=0;a<r;a+=8){const R=(Math.floor(a/8)*8).toString(16).padStart(t,"0"),T=new Array(8).fill(0).map(($,P)=>(this.memory[a+P]||0).toString(16).padStart(this.bits/4,"0"));console.log(`${R} | ${T.join(" ")}`)}console.log("----MEMORY-END----"),console.log("--REGISTER-BEGIN--"),Object.keys(this.registers).forEach(a=>{console.log(`${a.padStart(3," ")}: (0x${this.registers[a].getValue().toString(16)}, ${this.registers[a].getValue().toString(10)}, 0b${this.registers[a].getValue().toString(2).padStart(this.bits,"0")})`)}),console.log("---REGISTER-END---")}storeInstructionInMemory(e,t){this.setMemory(e,t.opcode),this.setMemory(e+1,t.operand)}fetchDecodeInstruction(e){this.verbose&&console.log(`Fetching instruction at address 0x${e.toString(16).padStart(this.bits/4,"0")}`);const t={opcode:this.readMemory(e),operand:this.readMemory(e+1)};if(t.opcode===void 0||t.operand===void 0)throw new Error("Fail to fetch instruction at address "+e);return this.verbose&&console.log(`Decoded: [OPCODE: ${v(t.opcode)}(0x${t.opcode.toString(16).padStart(2,"0")}), OPERAND:(0x${t.operand.toString(16).padStart(this.bits/4,"0")}, ${t.operand.toString(10)}, 0b${t.operand.toString(2).padStart(this.bits,"0")})]`),t}async executeInstruction(){this.end=!1;const e={opcode:this.registers.CIR.getValue(),operand:this.registers.MDR.getValue()};switch(e.opcode){case c.LDM:{this.registers.ACC.setValue(e.operand);break}case c.LDD:{this.registers.ACC.setValue(this.readMemory(e.operand));break}case c.LDI:{const t=this.readMemory(e.operand);this.registers.ACC.setValue(this.readMemory(t));break}case c.LDX:{const t=e.operand+this.registers.IX.getValue();this.registers.ACC.setValue(this.readMemory(t));break}case c.LDR:{this.registers.IX.setValue(e.operand);break}case c.LDR_ACC:{this.registers.IX.setValue(this.registers.ACC.getValue());break}case c.MOV:{const t=A(e.operand);this.registers.IX.setValue(this.registers[t].getValue());break}case c.STO:{this.setMemory(e.operand,this.registers.ACC.getValue());break}case D.IN:{this.registers.ACC.setValue(i(await this.inputDevice(),this.bits));break}case D.OUT:{this.outputDevice(u(this.registers.ACC.getValue(),this.bits));break}case g.ADD_ADDRESS:{const t=b(this.registers.ACC.getValue(),this.readMemory(e.operand),this.bits);this.registers.ACC.setValue(i(t,this.bits));break}case g.ADD_IMMEDIATE:{const t=b(this.registers.ACC.getValue(),e.operand,this.bits);this.registers.ACC.setValue(i(t,this.bits));break}case g.SUB_ADDRESS:{const t=I(this.registers.ACC.getValue(),this.readMemory(e.operand),this.bits);this.registers.ACC.setValue(i(t,this.bits));break}case g.SUB_IMMEDIATE:{const t=I(this.registers.ACC.getValue(),e.operand,this.bits);this.registers.ACC.setValue(i(t,this.bits));break}case g.DEC:{const t=A(e.operand);this.registers[t].decreaseBy(1);break}case g.INC:{const t=A(e.operand);this.registers[t].increaseBy(1);break}case C.JMP:{this.jumped=!0,this.registers.PC.setValue(e.operand);break}case C.JPE:{this.isCMPSuccessful()&&(this.jumped=!0,this.registers.PC.setValue(e.operand));break}case C.JPN:{this.isCMPSuccessful()||(this.jumped=!0,this.registers.PC.setValue(e.operand));break}case C.JMR:{this.isCMPSuccessful()&&(this.jumped=!0,this.registers.PC.increaseBy(e.operand));break}case d.LSL:{const t=this.registers.ACC.getValue(),r=V(t,e.operand);this.registers.ACC.setValue(r);break}case d.LSR:{const t=this.registers.ACC.getValue(),r=E(t,e.operand);this.registers.ACC.setValue(r);break}case d.ASR:{const t=this.registers.ACC.getValue(),r=f(t,e.operand,this.bits);this.registers.ACC.setValue(r);break}case d.CSL:{const t=this.registers.ACC.getValue(),r=y(t,e.operand,this.bits);this.registers.ACC.setValue(r);break}case d.CSR:{const t=this.registers.ACC.getValue(),r=N(t,e.operand,this.bits);this.registers.ACC.setValue(r);break}case h.AND_IMMEDIATE:{this.registers.ACC.setValue(this.registers.ACC.getValue()&e.operand);break}case h.AND_ADDRESS:{this.registers.ACC.setValue(this.registers.ACC.getValue()&this.readMemory(e.operand));break}case h.OR_IMMEDIATE:{this.registers.ACC.setValue(this.registers.ACC.getValue()|e.operand);break}case h.OR_ADDRESS:{this.registers.ACC.setValue(this.registers.ACC.getValue()|this.readMemory(e.operand));break}case h.XOR_IMMEDIATE:{this.registers.ACC.setValue(this.registers.ACC.getValue()^e.operand);break}case h.XOR_ADDRESS:{this.registers.ACC.setValue(this.registers.ACC.getValue()^this.readMemory(e.operand));break}case h.NOT:{this.registers.ACC.setValue(i(~this.registers.ACC.getValue(),this.bits));break}case C.END:{this.end=!0;break}case p.CMP_ADDRESS:{const t=this.registers.ACC.getValue()-this.readMemory(e.operand);this.setStatusRegisterWithNumber(t),this.verbose&&console.log("Compare result: "+this.isCMPSuccessful());break}case p.CMP_IMMEDIATE:{const t=this.registers.ACC.getValue()-e.operand;this.setStatusRegisterWithNumber(t),this.verbose&&console.log("Compare result: "+this.isCMPSuccessful());break}case p.CMI:{const t=this.registers.ACC.getValue()-this.readMemory(this.readMemory(e.operand));this.setStatusRegisterWithNumber(t),this.verbose&&console.log("Compare result: "+this.isCMPSuccessful());break}case 255:throw new Error("Cannot treat a data type as an instruction: "+e.opcode.toString(16));default:throw new Error("Invalid instruction opcode: 0x"+e.opcode.toString(16))}}}let M=8,S=s=>s;const O=()=>new Promise(s=>{S=e=>(S=t=>t,s(parseInt(e)),e),self.postMessage({action:"input"})}),_=async s=>{const e=s<0?"-":"",t=`(0x${e}${Math.abs(s).toString(16).padStart(Math.ceil(M/4),"0")}, ${s.toString(10)}, 0b${e}${Math.abs(s).toString(2).padStart(M,"0")}, CHAR: "${String.fromCharCode(s)}")
`;self.postMessage({action:"output",msg:t})};self.onmessage=async s=>{if(s.data.action==="run"){M=s.data.bits;const{code:e,verbose:t}=s.data;if(M<8)throw new Error("Bits must be greater than 8");const r=new w(M);r.addDevice("input",O),r.addDevice("output",_),r.verbose=t,await r.execute(e),self.postMessage({action:"stop"})}s.data.action==="input-reply"&&S(s.data.msg)}})();
